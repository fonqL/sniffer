需求调查
界面设计与前端逻辑、
抓包实现，解析字段，各种功能函数（后端、文件保存与读取
统计结果分析之类的界面要展示的东西
写文档，画工程图
测试


1.抓取报文，将报文在网络层和传输层逐字段展开，制作GUI界面，协助其他组员完成任务


2.制作过滤器，统计数据


3.将数据存为文件，读取并展示为统计图








1. 界面
2. 统计
3. 过滤器
4. 文件倒没事，只要把原始二进制丢进去就好了（丢进默认的文件里到时候保存再复制出来）

{
   1. pcap得到数据流，然后解析头，丢进容器里(vector<vector<any>>)
   std::vector, std::any 的知识可以上网搜搜

   简单解释：内层表示解析出的各种协议头，外层表示所有数据包

   2. 如果这个数据包里有A协议，则A对应的vector<uint_t>加入在 ↑ 中数据包对应的下标作为索引（不能是指针，因为vector扩容时会失效）
}

{
   3. listview，treeview：
   读取vector<vector<any>>，因为第一层协议必是以太帧，而下层协议字段里有上层协议的类型信息，所以类型信息足够了
   先仅提供给定字符串对同名字段的查询
   负责展示，函数接口大致为: void fun(const vector<vector<any>>& packets, const vector<uint_t>& indexs) //和过滤器配合
}

{
   4. 过滤器：格式：协议.字段[.字段] 运算符 值。比如 ip.src == "123.456.789.000"
   用上各协议的索引容器。
   可以用正则表达式来解析。std::regex。
   也可以用qt的正则。随便
   函数接口大致为：vector<uint_t> fun(const vector<vector<any>>& packets, const vector<uint_t>& indexs)

   捕获过滤器也是支持的，界面记得留个功能。具体实现丢给底层（1,2）
}

5. 统计：各索引容器的大小即可

注意因为不可能实现所有的协议（比如http都懒得写了），所以展示的话直接用个unknown protocal之类的作为一个默认备选项
这个交给界面来处理

技巧:

如果觉得uint_t太丑了可以typedef uint_t uint或using uint = uint_t

头文件和cpp文件分不分离我认为无所谓
但是如果在头文件定义的话要加个inline：
inline f() {}
不然会报错

函数先搜搜c++里有没有再自己实现（严格来说是标准库里有没有






















