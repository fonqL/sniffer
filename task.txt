需求调查
界面设计与前端逻辑、
抓包实现，解析字段，各种功能函数（后端、文件保存与读取
统计结果分析之类的界面要展示的东西
写文档，画工程图
测试


1.抓取报文，将报文在网络层和传输层逐字段展开，制作GUI界面，协助其他组员完成任务


2.制作过滤器，统计数据


3.将数据存为文件，读取并展示为统计图








1. 界面
2. 统计
3. 过滤器
4. 文件倒没事，只要把原始二进制丢进去就好了（丢进默认的文件里到时候保存再复制出来）

{
   1. pcap得到数据流，然后解析头，丢进容器里(SafeQueue<vector<any>>)
   std::vector, std::any 的知识可以上网搜搜

   简单解释：内层表示解析出的各种协议头，外层表示所有数据包

   2. 如果这个数据包里有A协议，则A对应的vector<uint_t>加入在 ↑ 中数据包对应的下标作为索引（不能是指针，因为vector扩容时会失效）
}

{
   3. listview，treeview：
   读取SafeQueue<vector<any>>，因为第一层协议必是以太帧，而下层协议字段里有上层协议的类型信息，所以类型信息足够了
   先仅提供给定字符串对同名字段的查询
   负责展示.
   这个接口不好设计，是调用方，需要的话可以往mainwindow里塞成员变量。
   界面1.选择：是从网络抓还是打开文件
   界面2.选择网卡
   界面3.抓包界面
}

{
   4. 过滤器：格式：协议.字段[.字段] 运算符 值。比如 ip.src == "123.456.789.000"
   用上各协议的索引容器。
   可以用正则表达式来解析。std::regex。
   也可以用qt的正则。随便
   函数接口大致为：vector<uint_t> fun(const SafeQueue<vector<any>>& packets, const vector<uint_t>& indexs)
   或者：bool fun(const vector<any>& packets)
   捕获过滤器也是支持的，界面记得留个功能。具体实现丢给底层（1,2）
}

5. 统计：各索引容器的大小即可

注意因为不可能实现所有的协议（比如http都懒得写了），所以展示的话直接用个unknown protocal之类的作为一个默认备选项
这个交给界面来处理

！！！接口类型变动！！！
新的约定：
1.
存放数据包的结构为SafeQueue，是一个线程安全的先入先出队列。
抓包方为生产者，界面方是消费者。
SafeQueue不支持遍历。消费者一方必须从队列里拿出来放进自己的容器数据结构里然后处理。

2.
原先代表数据包的协议头结构的vector<any>含义发生变化：
现在是：
vector<any>中的第一项（vec[0]）的类型为simple_info，在handle_packet.h里定义。
含有捕获的时刻和原始bit流信息。
（因为才发现wireshark里显示的十六进制bit是未处理过的。。


过滤器的工作方式：
1. 捕获时过滤：这样子比较方便
   比如"tcp.src==53" //源端口是53
   bool filter(const vector<std::any> &packet)
      if(packet[3].type()==typeid(tcp_header)) { //tcp在第三层
         if(std::any_cast<const tcp_header&>(packet[3]).src == 53)
            return true;
      }
      return false;
   虽然在停止捕获后过滤时要全部遍历一遍，没有索引那么准，但是挺好用
   索引方便的是只要在容器里拿出一个下标，一堆包[下标] 的这个包就绝对是特定的协议包，即不用再次判断。
   索引作为一个后期的优化吧，可以先不实现。








