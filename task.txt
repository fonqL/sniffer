需求调查
界面设计与前端逻辑、
抓包实现，解析字段，各种功能函数（后端、文件保存与读取
统计结果分析之类的界面要展示的东西
写文档，画工程图
测试


1.抓取报文，将报文在网络层和传输层逐字段展开，制作GUI界面，协助其他组员完成任务


2.制作过滤器，统计数据


3.将数据存为文件，读取并展示为统计图








1. 界面
2. 统计
3. 过滤器
4. 文件倒没事，只要把原始二进制丢进去就好了（丢进默认的文件里到时候保存再复制出来）

{
   1. pcap得到数据流，然后解析头，丢进容器里(vector<vector<any>>)
   std::vector, std::any 的知识可以上网搜搜

   简单解释：内层表示解析出的各种协议头，外层表示所有数据包

   2. 如果这个数据包里有A协议，则A对应的vector<uint_t>加入在 ↑ 中数据包对应的下标作为索引（不能是指针，因为vector扩容时会失效）
}

{
   3. listview，treeview：
   读取vector<vector<any>>，因为第一层协议必是以太帧，而下层协议字段里有上层协议的类型信息，所以类型信息足够了
   先仅提供给定字符串对同名字段的查询
   负责展示.
   这个接口不好设计，是调用方，需要的话可以往mainwindow里塞成员变量。
}

{
   4. 过滤器：格式：协议.字段[.字段] 运算符 值。比如 ip.src == "123.456.789.000"
   用上各协议的索引容器。
   可以用正则表达式来解析。std::regex。
   也可以用qt的正则。随便
   函数接口大致为：vector<uint_t> fun(const vector<vector<any>>& packets, const vector<uint_t>& indexs)
   或者：bool fun(const vector<any>& packets)
   捕获过滤器也是支持的，界面记得留个功能。具体实现丢给底层（1,2）
}

5. 统计：各索引容器的大小即可

注意因为不可能实现所有的协议（比如http都懒得写了），所以展示的话直接用个unknown protocal之类的作为一个默认备选项
这个交给界面来处理

技巧:

如果觉得uint32_t/unsigned太丑了可以用qt的uint

头文件和cpp文件分不分离我认为无所谓
但是如果在头文件定义的话要加个inline：
inline f() {}
不然会报错

函数先搜搜c++里有没有再自己实现（严格来说是标准库里有没有

有个注意事项：
用无符号整数是因为负数在这些情况下是没意义的。
不过循环递减时要注意一下坑：
for(uint_t i = 10; i >= 0; i--) / uint i = 10; while(i >= 0) {...; i--;}
是错误的写法，因为无符号不会出现i < 0的情况。0 - 1会循环到2^32 - 1。
正确的写法：
for(uint_t i = 11; i > 0; --i) / uint i = 11; while(i-- > 0) {...;}
这时候后置--的作用就体现出来了
坚持区间左闭右开一百年不动摇（














