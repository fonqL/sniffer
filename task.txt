需求调查
界面设计与前端逻辑、
抓包实现，解析字段，各种功能函数（后端、文件保存与读取
统计结果分析之类的界面要展示的东西
写文档，画工程图
测试


1.抓取报文，将报文在网络层和传输层逐字段展开，制作GUI界面，协助其他组员完成任务


2.制作过滤器，统计数据


3.将数据存为文件，读取并展示为统计图








1. 界面
2. 统计
3. 过滤器
4. 文件倒没事，只要把原始二进制丢进去就好了（丢进默认的文件里到时候保存再复制出来）

{
   1. pcap得到数据流，然后解析头，丢进容器里(vector<vector<any>>)
   std::vector, std::any 的知识可以上网搜搜

   简单解释：内层表示解析出的各种协议头，外层表示所有数据包

   2. 如果这个数据包里有A协议，则A对应的vector<uint_t>加入在 ↑ 中数据包对应的下标作为索引（不能是指针，因为vector扩容时会失效）
}

{
   3. listview，treeview：
   读取vector<vector<any>>，因为第一层协议必是以太帧，而下层协议字段里有上层协议的类型信息，所以类型信息足够了
   先仅提供给定字符串对同名字段的查询
   负责展示.
   这个接口不好设计，是调用方，需要的话可以往mainwindow里塞成员变量。
   界面1.选择：是从网络抓还是打开文件
   界面2.选择网卡
   界面3.抓包界面
}

{
   4. 过滤器：格式：协议.字段[.字段] 运算符 值。比如 ip.src == "123.456.789.000"
   用上各协议的索引容器。
   可以用正则表达式来解析。std::regex。
   也可以用qt的正则。随便
   函数接口大致为：vector<uint_t> fun(const vector<vector<any>>& packets, const vector<uint_t>& indexs)
   或者：bool fun(const vector<any>& packets)
   捕获过滤器也是支持的，界面记得留个功能。具体实现丢给底层（1,2）
}

5. 统计：各索引容器的大小即可

注意因为不可能实现所有的协议（比如http都懒得写了），所以展示的话直接用个unknown protocal之类的作为一个默认备选项
这个交给界面来处理















